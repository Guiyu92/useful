- [1. 程序入口main函数](#1-程序入口main函数)
  - [1.1. main函数退出返回值](#11-main函数退出返回值)
  - [1.2. main函数获取参数](#12-main函数获取参数)
- [2. 测试](#2-测试)
- [3. 类型声明](#3-类型声明)
  - [3.1. 普通类型声明](#31-普通类型声明)
  - [3.2. 常量定义](#32-常量定义)
  - [3.3. 注意事项](#33-注意事项)
- [4. 运算符](#4-运算符)
  - [4.1. 有++和--操作，只能放在变量后边](#41-有和--操作只能放在变量后边)
  - [4.2. ==](#42-)
  - [4.3. 按位清0运算符&^](#43-按位清0运算符)
- [5. 条件](#5-条件)
  - [5.1. if支持2段写法，条件赋值](#51-if支持2段写法条件赋值)
  - [5.2. switch](#52-switch)
- [6. 数组](#6-数组)
  - [6.1. 数组遍历](#61-数组遍历)
  - [6.2. 支持类似python的切片](#62-支持类似python的切片)



# 1. 程序入口main函数
```
    1. 必须是main包 package main 
    2. 必须是main方法 func main
```
## 1.1. main函数退出返回值
```
    使用os.Exit(0) //0表示正常退出， -1表示异常
```
##  1.2. main函数获取参数
```
    main函数不支持传入参数，需要使用os.Args
```


# 2. 测试
```
    1.文件需要以_test下划线结尾
    2.类名需要Test开头,后续有分隔符或者大写
```

# 3. 类型声明
## 3.1. 普通类型声明
```
    var a int = 1
	var b int = 1

	var(
		a int = 1
		b = 2
	)
    
	a := 1
	b := 1
```
## 3.2. 常量定义
```
    iota是golang语言的常量计数器,只能在常量的表达式中使用。
    iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。

    常量中的未赋值的每一行和第一行一样，iota依次递增

    const (
		Mondy = iota + 1
		Tuesday
		Wednesday 
	)


	const (
		Readable = 1 << iota
		Writable
	)

    t.Log(Tuesday, Writable)
    输出 2 2 

```
## 3.3. 注意事项
```
    1. 不允许任何类型的隐式类型转换
    2. 别名不允许到原类型的隐式转换
    列：
        type MyInt int64
        var b int64 = 1
        var a MyInt
        a = b //报错
        需要强制转换
        a = MyInt(b)

    3. 指正类型不支持运算
        
```

# 4. 运算符
## 4.1. 有++和--操作，只能放在变量后边
## 4.2. ==
```
    1. 对于数组比较的是值得相等，不是引用或地址
    2. 数组必须数组的长度一样的时候才能进行比较，数组中元素的位置和值一模一样的才算相同
```
## 4.3. 按位清0运算符&^
```
    1 &^ 0 = 1
    1 &^ 1 = 1

    以下为而进行直观表示， 如果位上是1则该位清零，如果是0则该位不变
    11011 &^ 11000 = 00011
```


# 5. 条件
## 5.1. if支持2段写法，条件赋值
```
    if var declaration; contion{

    }

    if a, err := someFunc(); err{

    }
    else{

    }
```

## 5.2. switch
```
    1. 命中case后不需要break来退出，会默认退出
    2. 可以不设置switch后的条件表达式，表明是个大的if else
        c := 10
        switch  {
        case c == 9:
            t.Log(9)
        case c == 10:
            t.Log(10)
        }
    3. case 后面支持多个项的匹配
        case 2,3:
            ...
    4. switch后的条件语句也可以像if一样支持2段写法
```


# 6. 数组
```
    var a [3]int //默认值为0

    # 一维
    a := [3]int{1,2,3} //[...]{1,2,3}
    # 二维
    b := [3][2]int{{1,2}, {3,4}, {4,5}}

    注意：a := []int{1,2} 这样声明的数组是切片，不能用于==比较

    使用make初始化
    c := make([]int, 3, 10) //3是长度10是容量， 可用len和cap来读取
```
## 6.1. 数组遍历
```
    for index, e := range a{
		t.Log(index, e)
	}
```
## 6.2. 支持类似python的切片
```
    切片返回的数据是个结构体，有切片长度，切片数据，和切片容量，对于同一个数组的不同切片数据是共享的，也就是切片是指向地址的。

    切片的容量是基于数据容量计算的， cap(arr)-切片启始长度+1

```





